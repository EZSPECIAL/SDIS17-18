---------------------
ORDER
---------------------

    - reclaim
    - enh backup
    - enh restore
    - enh delete
    - protocol version dependent behavior (1.0 base 1.1 enh)

    - concurrentlinkedqueue -> channels send here
    - ConcurrentHashMap(8, 0.9f, 1);
    - Serializable needed on all DB objects
    - System.setProperty("java.net.preferIPv4Stack", "true")

---------------------
GRADE
---------------------

    - 70% (concurrent with all protocols)
    - 15% - 5% per enhancement
    - 5% - RMI
    - 5% - concurrency model in report
    - 5% - demo setup

---------------------
THREADING
---------------------

Version 6

    - I/O concurrency with java.nio.channels.AsynchronousFileChannel

---------------------
DATABASE & DISK
---------------------

    - max disk space and keep count of chunk disk space usage (start with 8MB)
    - local database of everything in the system
    - "STATE" protocol
    - "A peer should also count the number of confirmation messages for each of the chunks it has stored and keep that
    count in non-volatile memory. This information can be useful if the peer runs out of disk space: in that event,
    the peer may try to free some space by evicting chunks whose actual replication degree is higher than the desired
    replication degree."

---------------------
PROTOCOLS
---------------------

Reclaim

    Initiator
    - MC -> REMOVED <Version> <SenderId> <FileId> <ChunkNo> <CRLF><CRLF>
    - Peers receiving this message that have the chunk update the local repDeg count
    - If repDeg count is below desired for that chunk, starts Backup protocol with delay (0 to 400ms)
    - If during 0 to 400ms delay a PUTCHUNK for the same chunk is received, abort

---------------------
DELIVERY & DEMO
---------------------

Report
    - 1 page per enhancement (backup, restore, delete)
    - 2-3 pages for concurrency model

Setup
    - scripts for quick testing
    - check svn command for checkout
    - test PCs in lab, local and remote

---------------------
CLIENT
---------------------

    Get info ->
        For each file Peer has initiated backup of
            - file pathname
            - backup file service ID
            - desired repDeg
        For each chunk of the file
            - id
            - perceived repDeg
        For each chunk it stores
            - id
            - size in KB
            - perceived repDeg
        Curr KB used / max KB possible

---------------------
ENHANCEMENTS
---------------------

Backup

    - ensure repDegre
    - keep interoperability
    - what if not enough peers or disk space on them?

Restore (using TCP)

    - ServerSocket - start TCP connection
    - Socket - transfer data
    - ServerSocket(int port)
    - ServerSocket(int port, int backlog, InetAddress addr)
    - Socket(InetAddress addr, int port)

    - socket.accept() - wait for connection
    - socket.close() / shutdownOutput()

    - getInputStream() BufferedReader -> ReadLine()
    - getOutputStream() PrintWriter -> println()
    - ObjectInputStream() implements Serializable
    - ObjectOutputStream() implements Serializable

    - multiple clients

Delete

    - delete chunks even if Peer is currently offline

If adding messages

    - add a new header line
    - change protocol version to 1.1+

---------------------
EXTRAS
---------------------

    - Channel queue messages and 1 thread for each queue processing
    - PUTCHUNK sliding window
    - every protocol playing nice with each other (prevent same peer same protocol same file)
    - RMI over network, "//host/name" format
    - DELETE ENH: sync filelist